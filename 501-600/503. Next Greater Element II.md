# 503. Next Greater Element II

- Difficulty: Medium.
- Related Topics: Array, Stack, Monotonic Stack.
- Similar Questions: Next Greater Element I, Next Greater Element III.

## Problem

Given a circular integer array ```nums``` (i.e., the next element of ```nums[nums.length - 1]``` is ```nums[0]```), return **the **next greater number** for every element in** ```nums```.

The **next greater number** of a number ```x``` is the first greater number to its traversing-order next in the array, which means you could search circularly to find its next greater number. If it doesn't exist, return ```-1``` for this number.

 
**Example 1:**

```
Input: nums = [1,2,1]
Output: [2,-1,2]
Explanation: The first 1's next greater number is 2; 
The number 2 can't find next greater number. 
The second 1's next greater number needs to search circularly, which is also 2.
```

**Example 2:**

```
Input: nums = [1,2,3,4,3]
Output: [2,3,4,-1,4]
```

 
**Constraints:**


	
- ```1 <= nums.length <= 104```
	
- ```-109 <= nums[i] <= 109```



## Solution (Java)

```java
class Solution {
    public int[] nextGreaterElements(int[] nums) {
        int[] result = new int[nums.length];
        Deque<Integer> stack = new ArrayDeque<>();
        for (int i = nums.length * 2 - 1; i >= 0; i--) {
            while (!stack.isEmpty() && nums[stack.peek()] <= nums[i % nums.length]) {
                stack.pop();
            }
            result[i % nums.length] = stack.isEmpty() ? -1 : nums[stack.peek()];
            stack.push(i % nums.length);
        }
        return result;
    }
}
```

**Explain:**

nope.

**Complexity:**

* Time complexity : O(n).
* Space complexity : O(n).
